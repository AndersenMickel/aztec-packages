

// AUTOGENERATED FILE
#pragma once

#include "barretenberg/common/throw_or_abort.hpp"
#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include "barretenberg/proof_system/arithmetization/arithmetization.hpp"
#include "barretenberg/proof_system/circuit_builder/circuit_builder_base.hpp"

#include "./Fib_trace.cpp"
#include "barretenberg/honk/flavor/generated/Fib_flavor.hpp"
#include "barretenberg/proof_system/arithmetization/generated/Fib_arith.hpp"
#include "barretenberg/proof_system/relations/generated/Fib.hpp"

using namespace barretenberg;

namespace proof_system {

class FibTraceBuilder {
  public:
    using FF = arithmetization::FibArithmetization::FF;
    using Row = Fib_vm::Row<FF>;

    // TODO: tempalte
    using Polynomial = honk::flavor::FibFlavor::Polynomial;
    using AllPolynomials = honk::flavor::FibFlavor::AllPolynomials;

    static constexpr size_t num_fixed_columns = 6;
    static constexpr size_t num_polys = 4;
    std::vector<Row> rows;

    [[maybe_unused]] void build_circuit()
    {

        // Build up the rows
        size_t n = 16;
        // Build the is_last column

        // Add first row that makes the shifted cols 0
        Row first_row = Row{ .Fibonacci_FIRST = 1 };
        rows.push_back(first_row);

        // The actual first row
        Row row = {
            .Fibonacci_x = 0,
            .Fibonacci_y = 1,
        };
        rows.push_back(row);

        for (size_t i = 2; i < n; i++) {
            FF x = rows[i - 1].Fibonacci_y;
            FF y = rows[i - 1].Fibonacci_x + rows[i - 1].Fibonacci_y;
            Row row = {
                .Fibonacci_x = x,
                .Fibonacci_y = y,
            };
            rows.push_back(row);
        }

        // Build the isLast row
        for (size_t i = 0; i < n; i++) {
            rows[i].Fibonacci_LAST = i == n - 1;
        }

        // Build the shifts
        for (size_t i = 2; i < n; i++) {
            Row& row = rows[i - 1];
            row.Fibonacci_x_shift = rows[(i) % rows.size()].Fibonacci_x;
            row.Fibonacci_y_shift = rows[(i) % rows.size()].Fibonacci_y;
        }
    }

    AllPolynomials compute_polynomials()
    {
        const auto num_rows = get_circuit_subgroup_size();
        AllPolynomials polys;

        // Allocate mem for each column
        for (size_t i = 0; i < num_fixed_columns; ++i) {
            polys[i] = Polynomial(num_rows);
        }

        for (size_t i = 0; i < rows.size(); i++) {
            polys.Fibonacci_LAST[i] = rows[i].Fibonacci_LAST;
            polys.Fibonacci_FIRST[i] = rows[i].Fibonacci_FIRST;
            polys.Fibonacci_x[i] = rows[i].Fibonacci_x;
            polys.Fibonacci_y[i] = rows[i].Fibonacci_y;
        }

        polys.Fibonacci_y_shift = Polynomial(polys.Fibonacci_y.shifted());
        polys.Fibonacci_x_shift = Polynomial(polys.Fibonacci_x.shifted());

        return polys;
    }

    [[maybe_unused]] bool check_circuit()
    {
        // Get the rows from file
        build_circuit();

        auto polys = compute_polynomials();
        const size_t num_rows = polys[0].size();

        const auto evaluate_relation = [&]<typename Relation>(const std::string& relation_name) {
            typename Relation::ArrayOfValuesOverSubrelations result;
            for (auto& r : result) {
                r = 0;
            }
            constexpr size_t NUM_SUBRELATIONS = result.size();

            for (size_t i = 0; i < num_rows; ++i) {
                Relation::accumulate(result, polys.get_row(i), {}, 1);

                bool x = true;
                for (size_t j = 0; j < NUM_SUBRELATIONS; ++j) {
                    if (result[j] != 0) {
                        throw_or_abort(
                            format("Relation ", relation_name, ", subrelation index ", j, " failed at row ", i));
                        x = false;
                    }
                }
                if (!x) {
                    return false;
                }
            }
            return true;
        };

        return evaluate_relation.template operator()<Fib_vm::Fib<FF>>("Fib");
    }

    [[nodiscard]] size_t get_num_gates() const { return rows.size(); }

    [[nodiscard]] size_t get_circuit_subgroup_size() const
    {
        const size_t num_rows = get_num_gates();
        const auto num_rows_log2 = static_cast<size_t>(numeric::get_msb64(num_rows));
        size_t num_rows_pow2 = 1UL << (num_rows_log2 + (1UL << num_rows_log2 == num_rows ? 0 : 1));
        return num_rows_pow2;
    }
};
} // namespace proof_system
