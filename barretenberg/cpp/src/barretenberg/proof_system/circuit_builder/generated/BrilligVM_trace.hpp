

// AUTOGENERATED FILE
#pragma once

#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include "barretenberg/proof_system/arithmetization/arithmetization.hpp"
#include "barretenberg/proof_system/circuit_builder/circuit_builder_base.hpp"

#include "./BrilligVM_trace.cpp"
#include "barretenberg/honk/flavor/generated/BrilligVM_flavor.hpp"
#include "barretenberg/proof_system/arithmetization/generated/BrilligVM_arith.hpp"
#include "barretenberg/proof_system/relations/generated/BrilligVM.hpp"

using namespace barretenberg;

namespace proof_system {

class BrilligVMTraceBuilder {
  public:
    using FF = arithmetization::BrilligVMArithmetization::FF;
    using Row = BrilligVM_vm::Row<FF>;

    // TODO: tempalte
    using Polynomial = honk::flavor::BrilligVMFlavor::Polynomial;
    using AllPolynomials = honk::flavor::BrilligVMFlavor::AllPolynomials;

    static constexpr size_t num_fixed_columns = 88;
    static constexpr size_t num_polys = 65;
    std::vector<Row> rows;

    [[maybe_unused]] void build_circuit() { rows = read_both_file_into_cols("../commits.bin", "../constants.bin"); }

    AllPolynomials compute_polynomials()
    {
        const auto num_rows = get_circuit_subgroup_size();
        AllPolynomials polys;

        // Allocate mem for each column
        for (size_t i = 0; i < num_fixed_columns; ++i) {
            polys[i] = Polynomial(num_rows);
        }

        for (size_t i = 0; i < rows.size(); i++) {
            polys.main_POSITIVE[i] = rows[i].main_POSITIVE;
            polys.main_FIRST[i] = rows[i].main_FIRST;
            polys.main_LAST[i] = rows[i].main_LAST;
            polys.main_STEP[i] = rows[i].main_STEP;
            polys.main__romgen_first_step[i] = rows[i].main__romgen_first_step;
            polys.main_first_step[i] = rows[i].main_first_step;
            polys.main_p_line[i] = rows[i].main_p_line;
            polys.main_p_X_const[i] = rows[i].main_p_X_const;
            polys.main_p_instr__jump_to_operation[i] = rows[i].main_p_instr__jump_to_operation;
            polys.main_p_instr__loop[i] = rows[i].main_p_instr__loop;
            polys.main_p_instr__reset[i] = rows[i].main_p_instr__reset;
            polys.main_p_instr_call[i] = rows[i].main_p_instr_call;
            polys.main_p_instr_call_param_l[i] = rows[i].main_p_instr_call_param_l;
            polys.main_p_instr_ret[i] = rows[i].main_p_instr_ret;
            polys.main_p_instr_return[i] = rows[i].main_p_instr_return;
            polys.main_p_reg_write_X_r0[i] = rows[i].main_p_reg_write_X_r0;
            polys.main_p_reg_write_X_r1[i] = rows[i].main_p_reg_write_X_r1;
            polys.main_p_reg_write_X_r3[i] = rows[i].main_p_reg_write_X_r3;
            polys.main__block_enforcer_last_step[i] = rows[i].main__block_enforcer_last_step;
            polys.main__linker_first_step[i] = rows[i].main__linker_first_step;
            polys.main_XInv[i] = rows[i].main_XInv;
            polys.main_XIsZero[i] = rows[i].main_XIsZero;
            polys.main_m_addr[i] = rows[i].main_m_addr;
            polys.main_m_step[i] = rows[i].main_m_step;
            polys.main_m_change[i] = rows[i].main_m_change;
            polys.main_m_value[i] = rows[i].main_m_value;
            polys.main_m_op[i] = rows[i].main_m_op;
            polys.main_m_is_write[i] = rows[i].main_m_is_write;
            polys.main_m_is_read[i] = rows[i].main_m_is_read;
            polys.main__operation_id[i] = rows[i].main__operation_id;
            polys.main__sigma[i] = rows[i].main__sigma;
            polys.main_pc[i] = rows[i].main_pc;
            polys.main_X[i] = rows[i].main_X;
            polys.main_Y[i] = rows[i].main_Y;
            polys.main_Z[i] = rows[i].main_Z;
            polys.main_jump_ptr[i] = rows[i].main_jump_ptr;
            polys.main_addr[i] = rows[i].main_addr;
            polys.main_tmp[i] = rows[i].main_tmp;
            polys.main_reg_write_X_r0[i] = rows[i].main_reg_write_X_r0;
            polys.main_r0[i] = rows[i].main_r0;
            polys.main_reg_write_X_r1[i] = rows[i].main_reg_write_X_r1;
            polys.main_r1[i] = rows[i].main_r1;
            polys.main_r2[i] = rows[i].main_r2;
            polys.main_reg_write_X_r3[i] = rows[i].main_reg_write_X_r3;
            polys.main_r3[i] = rows[i].main_r3;
            polys.main_r4[i] = rows[i].main_r4;
            polys.main_r5[i] = rows[i].main_r5;
            polys.main_r6[i] = rows[i].main_r6;
            polys.main_r7[i] = rows[i].main_r7;
            polys.main_r8[i] = rows[i].main_r8;
            polys.main_r9[i] = rows[i].main_r9;
            polys.main_r10[i] = rows[i].main_r10;
            polys.main_r11[i] = rows[i].main_r11;
            polys.main_instr_call[i] = rows[i].main_instr_call;
            polys.main_instr_call_param_l[i] = rows[i].main_instr_call_param_l;
            polys.main_instr_ret[i] = rows[i].main_instr_ret;
            polys.main_instr__jump_to_operation[i] = rows[i].main_instr__jump_to_operation;
            polys.main_instr__reset[i] = rows[i].main_instr__reset;
            polys.main_instr__loop[i] = rows[i].main_instr__loop;
            polys.main_instr_return[i] = rows[i].main_instr_return;
            polys.main_X_const[i] = rows[i].main_X_const;
            polys.main_X_free_value[i] = rows[i].main_X_free_value;
            polys.main_Y_free_value[i] = rows[i].main_Y_free_value;
            polys.main_Z_free_value[i] = rows[i].main_Z_free_value;
            polys.main__operation_id_no_change[i] = rows[i].main__operation_id_no_change;
        }

        polys.main_r7_shift = Polynomial(polys.main_r7.shifted());
        polys.main__romgen_first_step_shift = Polynomial(polys.main__romgen_first_step.shifted());
        polys.main_r0_shift = Polynomial(polys.main_r0.shifted());
        polys.main_r8_shift = Polynomial(polys.main_r8.shifted());
        polys.main_r1_shift = Polynomial(polys.main_r1.shifted());
        polys.main_r9_shift = Polynomial(polys.main_r9.shifted());
        polys.main_r10_shift = Polynomial(polys.main_r10.shifted());
        polys.main_m_is_write_shift = Polynomial(polys.main_m_is_write.shifted());
        polys.main_pc_shift = Polynomial(polys.main_pc.shifted());
        polys.main_tmp_shift = Polynomial(polys.main_tmp.shifted());
        polys.main_addr_shift = Polynomial(polys.main_addr.shifted());
        polys.main_jump_ptr_shift = Polynomial(polys.main_jump_ptr.shifted());
        polys.main_r11_shift = Polynomial(polys.main_r11.shifted());
        polys.main_r2_shift = Polynomial(polys.main_r2.shifted());
        polys.main_r3_shift = Polynomial(polys.main_r3.shifted());
        polys.main_m_value_shift = Polynomial(polys.main_m_value.shifted());
        polys.main_r5_shift = Polynomial(polys.main_r5.shifted());
        polys.main__operation_id_shift = Polynomial(polys.main__operation_id.shifted());
        polys.main__sigma_shift = Polynomial(polys.main__sigma.shifted());
        polys.main_r4_shift = Polynomial(polys.main_r4.shifted());
        polys.main_m_addr_shift = Polynomial(polys.main_m_addr.shifted());
        polys.main_r6_shift = Polynomial(polys.main_r6.shifted());
        polys.main_first_step_shift = Polynomial(polys.main_first_step.shifted());

        return polys;
    }

    [[maybe_unused]] bool check_circuit()
    {
        // Get the rows from file
        build_circuit();

        auto polys = compute_polynomials();
        const size_t num_rows = polys[0].size();

        const auto evaluate_relation = [&]<typename Relation>(const std::string& relation_name) {
            typename Relation::ArrayOfValuesOverSubrelations result;
            for (auto& r : result) {
                r = 0;
            }
            constexpr size_t NUM_SUBRELATIONS = result.size();

            for (size_t i = 0; i < num_rows; ++i) {
                Relation::accumulate(result, polys.get_row(i), {}, 1);

                bool x = true;
                for (size_t j = 0; j < NUM_SUBRELATIONS; ++j) {
                    if (result[j] != 0) {
                        info("Relation ", relation_name, ", subrelation index ", j, " failed at row ", i);
                        throw false;
                        x = false;
                    }
                }
                if (!x) {
                    return false;
                }
            }
            return true;
        };

        return evaluate_relation.template operator()<BrilligVM_vm::BrilligVM<FF>>("BrilligVM");
    }

    [[nodiscard]] size_t get_num_gates() const { return rows.size(); }

    [[nodiscard]] size_t get_circuit_subgroup_size() const
    {
        const size_t num_rows = get_num_gates();
        const auto num_rows_log2 = static_cast<size_t>(numeric::get_msb64(num_rows));
        size_t num_rows_pow2 = 1UL << (num_rows_log2 + (1UL << num_rows_log2 == num_rows ? 0 : 1));
        return num_rows_pow2;
    }
};
} // namespace proof_system
