use noirc_errors::{Location, Span};
use noirc_frontend::hir::def_collector::dc_crate::{
    DefCollector, UnresolvedFunctions, UnresolvedStruct,
};
use noirc_frontend::hir::def_map::ModuleData;
use noirc_frontend::macros_api::HirContext;
use noirc_frontend::node_interner::FuncId;
use noirc_frontend::{
    graph::CrateId,
    hir::def_map::{LocalModuleId, ModuleId},
    macros_api::{FileId, MacroError},
    NoirFunction,
};
use noirc_frontend::{Ident, NoirStruct, Path, TypeImpl, UnresolvedType};

pub fn inject_generated_fn(
    crate_id: &CrateId,
    module_id: LocalModuleId,
    file_id: FileId,
    def_collector: &mut DefCollector,
    context: &mut HirContext,
    func: NoirFunction,
) -> Result<FuncId, (MacroError, FileId)> {
    // TODO(#4373): We don't have a reasonable location for the source code of this autogenerated function, so we simply
    // pass an empty span. This function should not produce errors anyway so this should not matter.
    let location = Location::new(Span::empty(0), file_id);

    // These are the same things the ModCollector does when collecting functions: we push the function to the
    // NodeInterner, declare it in the module (which checks for duplicate definitions), and finally add it to the list
    // on collected but unresolved functions.

    let func_id = context.def_interner.push_empty_fn();
    context.def_interner.push_function(
        func_id,
        &func.def,
        ModuleId { krate: *crate_id, local_id: module_id },
        location,
    );

    context.def_map_mut(&crate_id).unwrap()
        .modules_mut()[module_id.0]
        .declare_function(
            func.name_ident().clone(), func_id
        ).map_err(|_| (
            MacroError { 
                primary_message: format!("Failed to declare the autogenerated {} function, likely due to a duplicate definition. See https://github.com/AztecProtocol/aztec-packages/issues/4647.", func.name()), 
                secondary_message: None, 
                span: None
            }, file_id)
           
        )?;

    def_collector
        .collected_functions
        .iter_mut()
        .find(|fns| fns.file_id == file_id)
        .ok_or((
            MacroError {
                primary_message: "ICE: no functions found in contract file".to_string(),
                secondary_message: None,
                span: None,
            },
            file_id,
        ))?
        .push_fn(module_id, func_id, func.clone());
    Ok(func_id)
}

pub fn inject_generated_fn_in_impl(
    crate_id: &CrateId,
    module_id: LocalModuleId,
    file_id: FileId,
    def_collector: &mut DefCollector,
    context: &mut HirContext,
    func: NoirFunction,
    impl_key: (UnresolvedType, LocalModuleId)
) -> Result<(), (MacroError, FileId)> { 
    let func_id = inject_generated_fn(crate_id, module_id, file_id, def_collector, context, func.clone())?;
    let existing_impl = def_collector.collected_impls.get_mut(&impl_key).ok_or((
        MacroError {
            primary_message: format!("Failed to find implementation for key {:?}", impl_key),
            secondary_message: None,
            span: None
        },
        file_id
    ))?;


    existing_impl.last_mut().unwrap().2.push_fn(module_id, func_id, func);
    Ok(())
}


pub fn inject_generated_fn_in_trait(
    crate_id: &CrateId,
    module_id: LocalModuleId,
    file_id: FileId,
    def_collector: &mut DefCollector,
    context: &mut HirContext,
    func: NoirFunction,
    trait_path: &Path
) -> Result<(), (MacroError, FileId)> { 
    let func_id = inject_generated_fn(crate_id, module_id, file_id, def_collector, context, func.clone())?;
    let trait_impl = def_collector.collected_traits_impls.iter_mut().find(| trait_impl | trait_impl.trait_path.last_segment().0.contents == trait_path.last_segment().0.contents).ok_or((
        MacroError {
            primary_message: format!("Failed to find trait implementation for trait_id {}", trait_path.last_segment().0.contents),
            secondary_message: None,
            span: None
        },
        file_id
    ))?;

    trait_impl.methods.push_fn(module_id, func_id, func);
    Ok(())
}


pub fn inject_generated_struct(
    crate_id: &CrateId,
    module_id: LocalModuleId,
    file_id: FileId,
    def_collector: &mut DefCollector,
    context: &mut HirContext,
    strct: NoirStruct,
) -> Result<(), (MacroError, FileId)> {
    let name = strct.name.clone();

    let unresolved = UnresolvedStruct { file_id, module_id, struct_def: strct };

    println!("Injecting generated struct {:?}", unresolved);


    // Create the corresponding module for the struct namespace
    let local_id = push_child_module(def_collector, &name, module_id, file_id, false, false)?;
    let id = context.def_interner.new_struct(&unresolved, *crate_id, local_id, file_id);

    println!("Generated struct id {:?}", id);

    // Add the struct to scope so its path can be looked up later
    let result = def_collector.def_map.modules[module_id.0].declare_struct(name, id);


    if let Err((first_def, second_def)) = result {
        return Err((
            MacroError {
                primary_message: format!(
                    "Failed to inject generated struct due to duplicate declaration {} - {}",
                    first_def, second_def
                ),
                secondary_message: None,
                span: None,
            },
            file_id,
        ));
    }

    // And store the TypeId -> StructType mapping somewhere it is reachable
    def_collector.collected_types.insert(id, unresolved);
    Ok(())
}


pub fn inject_generated_impl(
    crate_id: &CrateId,
    local_module_id: LocalModuleId,
    file_id: FileId,
    def_collector: &mut DefCollector,
    context: &mut HirContext,
    implementation: TypeImpl,
) -> Result<(), (MacroError, FileId)> {
    let krate = context.def_map(crate_id).unwrap().krate;

    let module_id = ModuleId { krate, local_id: local_module_id };

    let mut unresolved_functions =
        UnresolvedFunctions { file_id: file_id, functions: Vec::new(), trait_id: None };

    for (method, _) in &implementation.methods {
        let func_id = context.def_interner.push_empty_fn();
        let location = Location::new(method.span(), file_id);
        context.def_interner.push_function(func_id, &method.def, module_id, location);
        unresolved_functions.push_fn(local_module_id, func_id, method.clone());
    }

    let key = (implementation.object_type, local_module_id);
    let methods = def_collector.collected_impls.entry(key).or_default();
    methods.push((implementation.generics, implementation.type_span, unresolved_functions));

    Ok(())
}

fn push_child_module(
    def_collector: &mut DefCollector,
    mod_name: &Ident,
    parent_module_id: LocalModuleId,
    file_id: FileId,
    add_to_parent_scope: bool,
    is_contract: bool,
) -> Result<LocalModuleId, (MacroError, FileId)> {
    let parent = Some(parent_module_id);
    let location = Location::new(mod_name.span(), file_id);
    let new_module = ModuleData::new(parent, location, is_contract);
    let module_id = def_collector.def_map.modules.insert(new_module);

    let modules = &mut def_collector.def_map.modules;

    // Update the parent module to reference the child
    modules[parent_module_id.0].children.insert(mod_name.clone(), LocalModuleId(module_id));

    // Add this child module into the scope of the parent module as a module definition
    // module definitions are definitions which can only exist at the module level.
    // ModuleDefinitionIds can be used across crates since they contain the CrateId
    //
    // We do not want to do this in the case of struct modules (each struct type corresponds
    // to a child module containing its methods) since the module name should not shadow
    // the struct name.
    if add_to_parent_scope {
        let mod_id =
            ModuleId { krate: def_collector.def_map.krate, local_id: LocalModuleId(module_id) };

        if let Err((first_def, second_def)) =
            modules[parent_module_id.0].declare_child_module(mod_name.to_owned(), mod_id)
        {
            return Err((
                MacroError {
                    primary_message: format!(
                        "Failed to push child module due to duplicate declaration {} - {}",
                        first_def, second_def
                    ),
                    secondary_message: None,
                    span: None,
                },
                file_id,
            ));
        }
    }

    Ok(LocalModuleId(module_id))
}
