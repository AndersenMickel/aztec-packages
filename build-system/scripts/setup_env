#!/usr/bin/env bash
# This script sets up the global build environment. This should be called before any other build scripts,
# as the other build scripts assume these global variables are set. The global variables are written to
# the file in $BASH_ENV, which means that any new bash shells launched within the lifetime of the machine
# context will have these variables set. This happens for example when CircleCI runs a new "step".
# The script should be sourced from the root of the repository, e.g:
#   source ./build-system/scripts/setup_env
# This ensures the resultant variables are set in the calling shell.

# Save current options as we might be sourcing.
CURRENT_SHELL_OPTS=$(set +o)
trap 'eval "$CURRENT_SHELL_OPTS"' EXIT
[ -n "${BUILD_SYSTEM_DEBUG:-}" ] && set -x # conditionally trace
set -eu

COMMIT_HASH=$1
COMMIT_TAG=${2##*aztec-packages-}
JOB_NAME=$3
GIT_REPOSITORY_URL=${4:-}
BRANCH=${5:-}
PULL_REQUEST=${6:-}

BASH_ENV=${BASH_ENV:-}
ROOT_PATH=$(git rev-parse --show-toplevel)
BUILD_SYSTEM_PATH=$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)
PROJECT=$(cat $ROOT_PATH/PROJECT)
COMMIT_MESSAGE=$(git log -n 1 --pretty=format:"%s" $COMMIT_HASH)
PATH=$PATH:$BUILD_SYSTEM_PATH/scripts

check_env

export BRANCH

echo "External IP: $(curl -s ifconfig.me)"
echo
echo "COMMIT_HASH=$COMMIT_HASH"
echo "COMMIT_TAG=$COMMIT_TAG"
echo "JOB_NAME=$JOB_NAME"
echo "GIT_REPOSITORY_URL=$GIT_REPOSITORY_URL"
echo "BRANCH=$BRANCH"
echo "PULL_REQUEST=$PULL_REQUEST"

# If the user has requested to perform a "dry deploy", we set the commit tag to fake version, and set DRY_DEPLOY to 1.
if [[ "$COMMIT_MESSAGE" == *"[ci dry-deploy]"* ]]; then
  COMMIT_TAG=v999.999.999
  export DRY_DEPLOY=1
else
  export DRY_DEPLOY=0
fi

if should_deploy; then
  if [ -n "${COMMIT_TAG:-}" ]; then
    # Extract the deploy env from the commit tag, if it has one, e.g. testnet.
    # If we have one, we look something like v2.1.123-testnet.0. This is a "non production" release.
    if [[ "$COMMIT_TAG" == *"-"* ]]; then
      # Strips the trailing '.XX' from the end of the commit tag.
      TEMP=${COMMIT_TAG%.*}
      # Strips the 'vX.Y.ZZZ-' from the front of the commit tag, leaving the e.g. 'testnet'.
      DEPLOY_ENV=${TEMP##*-}
    elif [ ! "$DRY_DEPLOY" -eq 1 ]; then
      DEPLOY_ENV=prod
    else
      DEPLOY_ENV=dev
    fi
  else
    # If we're on master, this is our devnet.
    DEPLOY_ENV="dev"
  fi
fi

# - The deploy tag (used in api paths, subdomains), is a concatenation of the project name and deploy environment,
#   e.g. aztec-dev, aztec-testnet, or aztec-prod
if [ -n "${DEPLOY_ENV:-}" ]; then
  DEPLOY_TAG=$PROJECT-$DEPLOY_ENV
fi

if [ -z "$BASH_ENV" ]; then
  BASH_ENV=$(mktemp)
fi

# Ensure that we only ever set these env vars on the first bash instantiation.
# Otherwise every new invocation of bash will reset the vars.
cat >> $BASH_ENV << EOF
if [ -n "\$BUILD_SYSTEM_INITIALIZED" ]; then
  exit
fi

export BUILD_SYSTEM_INITIALIZED=1 >> $BASH_ENV
export DOCKER_HOST_X86="ssh://build-instance-x86"
export DOCKER_HOST_ARM="ssh://build-instance-arm"
export ROOT_PATH=$ROOT_PATH
export BUILD_SYSTEM_PATH=$BUILD_SYSTEM_PATH
export DOCKER_BUILDKIT=${DOCKER_BUILDKIT:-1}
export BUILDKIT_PROGRESS=plain
export SSH_CONFIG_PATH=$BUILD_SYSTEM_PATH/remote/ssh_config
export PATH=\$PATH:$BUILD_SYSTEM_PATH/scripts
export AWS_DEFAULT_REGION=eu-west-2
export ECR_REGION=us-east-2
export AWS_ACCOUNT=278380418400
export ECR_URL=278380418400.dkr.ecr.us-east-2.amazonaws.com
export ECR_DEPLOY_REGION=eu-west-2
export DOCKERHUB_ACCOUNT=aztecprotocol
export DOCKERHUB_USERNAME=aztecprotocolci
export PROJECT=$PROJECT
export COMMIT_HASH=$COMMIT_HASH
export COMMIT_TAG=$COMMIT_TAG
export COMMIT_MESSAGE='${COMMIT_MESSAGE//\'/\'\\\'\'}'
export JOB_NAME=$JOB_NAME
export GIT_REPOSITORY_URL=$GIT_REPOSITORY_URL
export DEPLOY_ENV=${DEPLOY_ENV:-}
export DEPLOY_TAG=${DEPLOY_TAG:-}
export BRANCH=$BRANCH
export PULL_REQUEST=$PULL_REQUEST
export DRY_DEPLOY=${DRY_DEPLOY:-0}
export DOCKER_CLI_HINTS=false
export GREEN="\033[32m"
export YELLOW="\033[33m"
export BLUE="\033[34m"
export PURPLE="\033[35m"
export RESET="\033[0m"
export BOLD="\033[1m"
EOF

# We want very strict failures on any failing command, undefined variable, or commands that pipe to other commands.
echo set -euo pipefail >> $BASH_ENV

# Enable logging if [ci debug] is in commit message.
if [[ "$COMMIT_MESSAGE" == *"[ci debug]"* ]]; then
  echo export BUILD_SYSTEM_DEBUG=1 >> $BASH_ENV
  echo set -x >> $BASH_ENV
fi

# Only run the following if we're the result of a commit (i.e. not being run manually).
if [ -n "$COMMIT_HASH" ]; then
  # Our alpine build image has yq installed, ubuntu build instances install from gzips in ../bin.
  if [ ! -f /etc/alpine-release ]; then
    BIN_PATH=$BUILD_SYSTEM_PATH/bin
    echo export PATH=$BIN_PATH:\$PATH >> $BASH_ENV
    ARCH=$(uname -m)
    if [ "$ARCH" == "x86_64" ]; then
      gunzip -c $BIN_PATH/yq_linux_amd64 > $BIN_PATH/yq
    elif [ "$ARCH" == "aarch64" ]; then
      gunzip -c $BIN_PATH/yq_linux_arm64 > $BIN_PATH/yq
    else
      echo "Unknown arch: $ARCH"
      exit 1
    fi
    chmod +x $BIN_PATH/yq
  fi

  # Install and ensure correct permissions on build instance key.
  mkdir -p ~/.ssh
  echo ${BUILD_INSTANCE_KEY:-} | base64 -d > ~/.ssh/build_instance_key
  chmod 600 ~/.ssh/build_instance_key

  if [[ "$COMMIT_MESSAGE" == *"[ci debug]"* ]]; then
    echo export BUILD_SYSTEM_DEBUG=1 >> $BASH_ENV
  fi
fi

# Allows us the demo using a new ci pipeline.
if [[ "$COMMIT_MESSAGE" == *"[ci new-ci]"* ]]; then
  # TODO: Add to build-image.
  if [ -f /etc/alpine-release ]; then
    apk add docker docker-compose
  fi
  # Seems docker doesn't honor SSH_CONFIG_PATH, so copy file.
  [ ! -f ~/.ssh/config ] && cp $BUILD_SYSTEM_PATH/remote/ssh_config ~/.ssh/config
  # Prioritise new scripts.
  echo export PATH=$BUILD_SYSTEM_PATH/scripts_new:\$PATH >> $BASH_ENV
fi

# Print for visibility.
cat $BASH_ENV

# Having written the variables to $BASH_ENV, we now want to set them in this shell context.
source $BASH_ENV
