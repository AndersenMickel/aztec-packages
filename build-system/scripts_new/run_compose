#!/usr/bin/env bash
# Runs a docker-compose file.
# Pulls the containers in the build manifests <project>.runDependencies property.
# Uploads any logs to S3.
# Can be used to test a built container (runDependencies would be self + dependency containers).
# Can be used to build and test a container (runDependencies would just be dependency containers).
# The trailing arguments are environment variables in the form KEY=VALUE, made available to docker-compose.

[ -n "${BUILD_SYSTEM_DEBUG:-}" ] && set -x # conditionally trace
set -eu

REPOSITORY=$1
COMPOSE_FILE=$2
shift 2

IMAGE_URI=$(calculate_image_uri $REPOSITORY)
BASE_TAG=$(calculate_image_tag $REPOSITORY)
SUCCESS_TAG=$BASE_TAG-$JOB_NAME

echo "Success tag: $SUCCESS_TAG"

if check_rebuild $SUCCESS_TAG $REPOSITORY; then
  echo "No re-run necessary for $IMAGE_URI."
  exit 0
fi

# Login to dockerhub.
retry dockerhub_login

cd $(query_manifest projectDir $REPOSITORY)

TARGET_COMPOSE_FILE=$(mktemp)
cp $COMPOSE_FILE $TARGET_COMPOSE_FILE

# For each dependency, substitute references to the dependency in compose file, with the relevent built image uri.
# This is necessary vs retagging the image, as that would cause conflicts between ci runs.
for DEP_REPO in $(query_manifest runDependencies $REPOSITORY); do
  # We want the parent image tag without any arch suffix.
  DEP_IMAGE_TAG=$(calculate_image_tag $DEP_REPO "")
  echo "Looking for image $DEP_REPO:$DEP_IMAGE_TAG..."

  # Attempt to locate image.
  if ! image_exists $DEP_REPO $DEP_IMAGE_TAG; then
    echo "Image not available. Aborting."
    exit 1
  fi

  # Substitute references to images, with the relevent built image uri.
  DEPLOY_URI=aztecprotocol/$DEP_REPO
  DEP_IMAGE_URI=$ECR_URL/$DEP_REPO:$DEP_IMAGE_TAG
  yq -i 'del(.services[].ports)' $TARGET_COMPOSE_FILE
  if [ "$(yq .services.$DEP_REPO.image $TARGET_COMPOSE_FILE)" != "null" ]; then
    yq -i ".services.$DEP_REPO.image = \"$DEP_IMAGE_URI\"" $TARGET_COMPOSE_FILE
  fi
done

cat $TARGET_COMPOSE_FILE

PROJECT=${COMMIT_HASH:-no-commit}-${JOB_NAME}

export $@
if docker compose > /dev/null 2>&1; then
  CMD="docker compose"
else
  CMD="docker-compose"
fi

X86=$(query_manifest x86 $REPOSITORY)
ARM=$(query_manifest arm $REPOSITORY)

function cleanup {
  [ "$X86" == "true" ] && DOCKER_HOST=$DOCKER_HOST_X86 $CMD -p $PROJECT down
  [ "$ARM" == "true" ] && DOCKER_HOST=$DOCKER_HOST_ARM $CMD -p $PROJECT down
  rm $TARGET_COMPOSE_FILE
}
trap cleanup EXIT

function run {
  $CMD -p $PROJECT -f $TARGET_COMPOSE_FILE up --exit-code-from $REPOSITORY --force-recreate 2>&1
  docker tag $IMAGE_URI $ECR_URL/$REPOSITORY:$SUCCESS_TAG
}

if [ "$X86" == "true" ]; then
  (DOCKER_HOST=$DOCKER_HOST_X86 run > >(awk -v c="$GREEN" -v r="$RESET" '$0=c"x86_64: "r $0')) &
fi
if [ "$ARM" == "true" ]; then
  (DOCKER_HOST=$DOCKER_HOST_ARM run > >(awk -v c="$BLUE" -v r="$RESET" '$0=c"arm64: "r $0')) &
fi

for job in $(jobs -p); do
  wait $job || exit 1
done

# upload_logs_to_s3 log