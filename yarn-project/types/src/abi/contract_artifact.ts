import { FUNCTION_TREE_HEIGHT } from '@aztec/circuits.js';
import {
  ABIParameter,
  ABIParameterVisibility,
  ABIType,
  ContractArtifact,
  FunctionArtifact,
  FunctionType,
} from '@aztec/foundation/abi';
import { NoirContractCompilationArtifact, parseNoirContractCompilationArtifact } from '@aztec/foundation/noir';



import { mockVerificationKey } from './mocked_keys.js';

/**
 * Parses nargo build output and returns a valid contract artifact instance.
 * Will also accept a ContractArtifact and just return it.
 * @param input - Input object as generated by nargo compile.
 * @returns A valid contract artifact instance.
 */
export function loadContractArtifact(input: any): ContractArtifact {
  if (isContractArtifact(input)) {
    return input;
  }
  const noirArtifact = parseNoirContractCompilationArtifact(input);
  const contractArtifact = generateContractArtifact(noirArtifact);
  validateContractArtifact(contractArtifact);
  return contractArtifact;
}

/**
 * Checks if the given input looks like a valid ContractArtifact. The check is not exhaustive,
 * and it's just meant to differentiate between nargo raw build artifacts and the ones
 * produced by this compiler.
 * @param input - Input object.
 * @returns True if it looks like a ContractArtifact.
 */
function isContractArtifact(input: any): input is ContractArtifact {
  if (typeof input !== 'object') {
    return false;
  }
  const maybeContractArtifact = input as ContractArtifact;
  if (typeof maybeContractArtifact.name !== 'string') {
    return false;
  }
  if (!Array.isArray(maybeContractArtifact.functions)) {
    return false;
  }
  for (const fn of maybeContractArtifact.functions) {
    if (typeof fn.name !== 'string') {
      return false;
    }
    if (typeof fn.functionType !== 'string') {
      return false;
    }
  }
  return true;
}

/** Parameter in a function from a noir contract compilation artifact */
type NoirContractCompilationArtifactFunctionParameter =
  NoirContractCompilationArtifactFunction['abi']['parameters'][number];

/**
 * Generates a function parameter out of one generated by a nargo build.
 * @param param - Noir parameter.
 * @returns A function parameter.
 */
function generateFunctionParameter(param: NoirContractCompilationArtifactFunctionParameter): ABIParameter {
  const { visibility } = param;
  if (visibility === 'databus') {
    throw new Error(`Unsupported visibility ${param.visibility} for noir contract function parameter ${param.name}.`);
  }
  return { ...param, visibility: visibility as ABIParameterVisibility };
}

/** Function from a noir contract compilation artifact */
type NoirContractCompilationArtifactFunction = NoirContractCompilationArtifact['functions'][number];

/**
 * Generates a function build artifact. Replaces verification key with a mock value.
 * @param fn - Noir function entry.
 * @returns Function artifact.
 */
function generateFunctionArtifact(fn: NoirContractCompilationArtifactFunction): FunctionArtifact {
  const functionType = fn.function_type.toLowerCase() as FunctionType;
  const isInternal = fn.is_internal;

  // If the function is not unconstrained, the first item is inputs or CallContext which we should omit
  let parameters = fn.abi.parameters.map(generateFunctionParameter);
  if (functionType !== 'unconstrained') {
    parameters = parameters.slice(1);
  }

  // If the function is secret, the return is the public inputs, which should be omitted
  let returnTypes: ABIType[] = [];
  if (functionType !== 'secret' && fn.abi.return_type) {
    returnTypes = [fn.abi.return_type.abi_type];
  }

  return {
    name: fn.name,
    functionType,
    isInternal,
    parameters,
    returnTypes,
    bytecode: fn.bytecode,
    verificationKey: mockVerificationKey,
  };
}

/** Validates contract artifact instance, throwing on error. */
function validateContractArtifact(contract: ContractArtifact) {
  const constructorArtifact = contract.functions.find(({ name }) => name === 'constructor');
  if (constructorArtifact === undefined) {
    throw new Error('Contract must have a constructor function');
  }
  if (contract.functions.length > 2 ** FUNCTION_TREE_HEIGHT) {
    throw new Error(`Contract can only have a maximum of ${2 ** FUNCTION_TREE_HEIGHT} functions`);
  }
  return contract;
}

/**
 * Given a Nargo output generates an Aztec-compatible contract artifact.
 * @param compiled - Noir build output.
 * @returns Aztec contract build artifact.
 */
function generateContractArtifact(
  contract: NoirContractCompilationArtifact,
  aztecNrVersion?: string,
): ContractArtifact {
  return {
    name: contract.name,
    functions: contract.functions.map(generateFunctionArtifact),
    events: contract.events,
    fileMap: contract.file_map,
    aztecNrVersion,
  };
}